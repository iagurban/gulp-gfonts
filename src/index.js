// Generated by LiveScript 1.5.0
(function(){
  var _, http, async, request, css, downloadCsses, prepareFontWeight, prepareFontFamily, main;
  _ = require('lodash');
  http = require('http');
  async = require('async');
  request = require('request');
  css = require('css');
  console.log('started');
  downloadCsses = function(options, next){
    return async.parallel(['Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36', 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)', null].map(function(ua){
      var this$ = this;
      return function(it){
        return it.bind(null, ua);
      }(function(ua, next){
        return request('http://fonts.googleapis.com/css?family=Spirax', {
          headers: {
            'User-Agent': ua != null ? ua : ''
          }
        }).on('response', function(response){
          var data;
          data = [];
          response.on('data', bind$(data, 'push'));
          response.on('error', next);
          return response.on('end', function(){
            next(null, data.join(''));
          });
        }).on('error', function(e){
          console.log('error', e);
          return next(e);
        });
      });
    }), function(e, r){
      next(e, r);
    });
  };
  prepareFontWeight = function(w){
    var ref$;
    switch (false) {
    case w != null:
      return 400;
    case !_.isString(w):
      if (w.match('^([0-9]+)$') != null) {
        return parseInt(w);
      } else {
        return (ref$ = weightsSymbolicMapping[w]) != null ? ref$ : 400;
      }
      break;
    default:
      return 400;
    }
  };
  prepareFontFamily = function(f){
    var ref$, ref1$;
    return (ref$ = (ref1$ = f.match(/^\'(.+)\'$/)) != null ? ref1$[1] : void 8) != null ? ref$ : f;
  };
  main = function(next){
    return async.waterfall([
      function(next){
        return next(null, 'args');
      }, downloadCsses, function(raws, next){
        var faces, signatures, remoteSrcs, signature;
        faces = raws.map(function(rawcss){
          var data, rules, this$ = this;
          data = css.parse(rawcss);
          rules = data[data.type].rules;
          return rules.filter(function(it){
            return it.type === 'font-face';
          }).map(function(it){
            var this$ = this;
            return _.fromPairs(it.declarations.filter(function(it){
              return it.type === 'declaration';
            }).map(function(it){
              return [it.property, it.value];
            }));
          });
        }).reduce(function(){
          return arguments[0].concat(arguments[1]);
        }, []);
        signatures = {};
        remoteSrcs = [];
        signature = function(it){
          var r, key$, ref$;
          r = {
            family: prepareFontFamily(it['font-family']),
            weight: prepareFontWeight(it['font-weight']),
            style: it['font-style'],
            range: it['unicode-range']
          };
          return (ref$ = signatures[key$ = _.map(r).join(':')]) != null
            ? ref$
            : signatures[key$] = import$(r, {
              srcs: [],
              add: function(it){
                var this$ = this;
                it.src.split(',').map(function(it){
                  var ref$;
                  return (ref$ = it.match(/^\s*(.*)\s*$/)) != null ? ref$[1] : void 8;
                }).forEach(function(it){
                  var ref$, full, url, format, x$, name;
                  switch (false) {
                  case !_.find(this$.srcs, it):
                    break;
                  case !((ref$ = it.match(/\s*url\(([^\)]+)\)\s*(?:format\(\'(.+)\'\))?\s*/)) != null && (full = ref$[0], url = ref$[1], format = ref$[2], ref$)):
                    x$ = {
                      priority: 1,
                      url: url,
                      format: format,
                      generate: function(){
                        return "<remote " + this.url + " (" + this.format + ")>";
                      }
                    };
                    remoteSrcs.push(x$);
                    this$.srcs.push(x$);
                    break;
                  case !((ref$ = it.match(/\s*local\(\'(.+)\'\)\s*/)) != null && (full = ref$[0], name = ref$[1], ref$)):
                    this$.srcs.push({
                      priority: 0,
                      name: name,
                      generate: function(){
                        return "<local " + this.name + ">";
                      }
                    });
                  }
                });
              },
              generate: function(){
                var this$ = this;
                return function(it){
                  return "@font-face {\n " + it + " \n}";
                }(
                _.map(_.assign({
                  'font-family': "'" + this.family + "'",
                  'font-style': this.style,
                  'font-weight': this.weight
                }, this.range != null ? {
                  'unicode-range': this.range
                } : void 8, {
                  src: _(this.srcs).filter(function(it){
                    return !it.invalid;
                  }).sort(function(it){
                    return it.priority;
                  }).map(function(it){
                    return it.generate();
                  }).join(', ')
                }), function(){
                  return arguments[1] + ": " + arguments[0];
                }).map(function(it){
                  return "\t" + it;
                }).join('\n'));
              }
            });
        };
        faces.forEach(function(it){
          signature(it).add(it);
        });
        return next(null, {
          signatures: signatures,
          remoteSrcs: remoteSrcs
        });
      }, function(arg$, next){
        var signatures, remoteSrcs, downloadFont, this$ = this;
        signatures = arg$.signatures, remoteSrcs = arg$.remoteSrcs;
        downloadFont = function(url, next){
          return async.waterfall([
            url, function(url, next){
              return request(url).on('response', function(response){
                var data;
                data = [];
                response.on('data', bind$(data, 'push'));
                response.on('error', next);
                return response.on('end', function(){
                  next(null, data.join(''));
                });
              }).on('error', function(e){
                console.log('error', e);
                return next(e);
              });
            }
          ], next);
        };
        return next(null, _.map(signatures, function(it){
          return it.generate();
        }).join('\n'));
      }
    ], next);
  };
  (function(){
    return main(function(err, r){
      console.log(r);
      if (err) {
        console.log('ERROR');
        throw err;
      }
      return process.exit(0);
    });
  })();
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
